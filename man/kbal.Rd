% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{kbal}
\alias{kbal}
\title{Kernel Balancing}
\usage{
kbal(allx, useasbases = NULL, b = NULL, sampled = NULL,
  sampledinpop = NULL, treatment = NULL, ebal.tol = 1e-06,
  numdims = NULL, minnumdims = NULL, maxnumdims = NULL,
  incrementby = 1, printprogress = TRUE)
}
\arguments{
\item{allx}{a data matrix containing all observations where rows are units and columns are covariates.}

\item{useasbases}{optional vector of 0/1 or FALSE/TRUE to specify what observations are to be used in forming bases (columns of the kernel matrix) balanced upon.  If the number of observations is under 2000, the default is to use all observations. When the number of observations is over 2000, the default is to use the sampled (control) units only.}

\item{b}{scaling factor in the calculation of gaussian kernel distance equivalent to the entire denominator \eqn{2\sigma^2} of the exponent.}

\item{sampled}{a numeric vector of length equal to the total number of units where sampled units take a value of 1 and population units take a value of 0.}

\item{sampledinpop}{a logical to be used in compination with input \code{sampled} that when \code{TRUE} indicates that sampled units should also be included in the target population.}

\item{treatment}{an alternative input to \code{sampled} and \code{sampledinpop} that is a numeric vector of length equal to the total number of units where population units take a value of 1 and sample units take a value of 0. Note that, current version only supports finding the ATT whihc implies \code{sampledinpop} is \code{FALSE}.}

\item{ebal.tol}{tolerance level used by \code{ebal::ebalance}.}

\item{numdims}{optional numeric argument to specify the number of dimensions of the kernel matrix to find balance on rather than searching for the number of dimensions which minimize the bias.}

\item{minnumdims}{optional numeric argument to specify the minimum number of dimensions of the SVD of the kernel matrix to find balance on in the search for the number of dimesions which minimize the bias. Default minimum is 1.}

\item{maxnumdims}{optional numeric argument to specify the maximum number of dimensions of the SVD of the kernel matrix to find balance on in the search for the number of dimesions which minimize the bias. While the number of observations is under 2000, the default maximum is the total number of observations. Due to the computation burden, when the number of observations is over 2000, the default is the number of sampled units.}

\item{incrementby}{optional argument to specify the number of dimesions to increase by from \code{minnumdims} to \code{maxnumdims} in each iteration of the search for the number of dimensions which minimizes the bias. Default is 1.}

\item{printprogress}{optional logical argument to print current number of dimensions and bias.}
}
\value{
\item{dist.record}{a numeric matrix recording the bias bound corresponding to balance on increasing dimesions of the SVD of the kernel matrix starting from \code{minnumdims} increasing by \code{incrementby} to \code{maxnumdims} or until the bias grows to be 1.25 times the minimal bias found.}
 \item{biasbound.orig}{the bias bound found when all sampled units have a weight of one over the number of sampled units and all target units have a weight of one over the number of target units.}
 \item{numdims}{the optimal number of dimensions of the SVD of the kernel matrix which minimizes the bias bound.}
 \item{w}{the weights found using entropy balancing on \code{numdims} dimensions of the SVD of the kernel matrix.}
 \item{biasbound.opt}{the minimal bias bound found using \code{numdims} as the number of dimestions of the SVD of the kernel matrix. When \code{numdims} is user-specified, the bias bound using this number of dimensions of the kernel matrix.}
\item{K}{the kernel matrix.}
}
\description{
Kernel balancing assumes the expectation of the non-treatment potential outcome conditional on the covariates falls in a large, flexible space of functions associated with a kernel. It then constructs linear bases for this function space and achieves approximate balance on these bases. This function implements kernel balancing using a gaussian kernel to expand the features of \eqn{X_i} to infinite dimensions.  It finds approximate mean balance for the control or sample group and treated group or target population in this expanded feature space by using the first \code{numdims} dimensions of the singular value decomposition of the gaussian kernel matrix. It employs entropy balancing to find the weights for each unit which produce this approximate balance. When \code{numdims} is not user-specified, it searches through increasing dimensions of the SVD of the kernel matrix to find the number of dimensions which produce weights that minimizes the worst-case bias bound with a given \code{hilbertnorm}. It then results these optimal weights, along with the minimized bias, the kernel matrix, a record of the number of dimensions used and the corresponding bais, as well as an original bias using naive group size weights for comparison.
}
\examples{
#Example 1:
#Run Lalonde example at (new) defaults:
data(lalonde)
lalonde$nodegr=as.numeric(lalonde$educ<=11)
xvars=c("age","black","educ","hisp","married","re74","re75","nodegr","u74","u75")
 
#Rerun Lalonde example with settings as in the KBAL paper:
kbalout.full= kbal(allx=lalonde[,xvars],
               useasbases=rep(1,nrow(lalonde)),
               treatment=lalonde$nsw)
 summary(lm(re78~nsw,w=kbalout.full$w, data = lalonde))  
 
 ############################################################
 ############################################################
 
 #Example 2:
 #Example of Population Weighting using Kpop as Opposed to Mean Balancing
 ######## Data Generation
 
 #Objective:
 #Suppose that we have a sample of 80 respondents giving their support for policy 
 #Our goal is to reweight this sample based on known covariates such that it is 
 #representative of the true population of 800 individuals
 #we want to get a good estimate of the average population support for policy A
 
 #Population values: 
 #suppose that there is unequal support for policy A among 4 groups:
 #white republicans, white democrats, non-white republicans, non-white democrats
 #for simplicity, suppose that white republicans support the policy 100\% 
 #and everyone else has support of 0\%
 #further assume the number of people in each of these groups in the population is even
 #since only a quarter of individuals in the population support A(200 white republicans),
 #our target estimate of the average population support for policy A is 25\%
 
 #fill population values 
 pop <- matrix(NA, nrow =800, ncol = 3)
 colnames(pop) <- c("Party", "Race", "Support_for_A")
 #fill Republican or Democrat: (400 of each) (1=Rep)
 pop[,1] <- c(rep(0,400), rep(1,400))
 #fill white or nonwhite: (400 of each, and 200 of each interaction with party) (white=1)
 pop[,2] <- c(rep(1,200), rep(0,200), rep(1,200), rep(0,200))
 #now fill the policy support: only 1 for white republicans, the first 200 rows
 pop[,3] <- c(rep(1,200), rep(0,600))
 #we can quickly confirm the target population estimate is 25\%
 mean(pop[,3])
 
 #Sample values:
 #now suppose that we have a sample of support for A among from 80 respondents
 #for the sake of simplicity, again assume that only white republicans support A w/100\%
 #and that all other groups have 0\% support
 #we know that party and race are probably important, but we do not know that the
 #their interaction is what really matters
 #so we stratify on race and party separately, ensuring equal repsonses from 
 #republicans and democrats (40 each), and white and non-whites (40 each)
 #and we end up with unequal numbers of the interacted groups such that we have:
 #30 white republicans, 10 non-white republicans,
 #10 white democrats, 30 nonwhite democrats
 #given that only white republicans support the policy, we will end up with
 #sample average support of 30/80 or 37.5\%
 
 #fill sample values:
 samp <- matrix(NA, nrow = 80, ncol = 3)
 colnames(samp) <- c("Party", "Race", "Support_for_A")
 #fill Republican or Democrat: (40 of each) (1=Rep)
 samp[,1] <- c(rep(1, 40), rep(0,40))
 #fill White or Non-white: 40 of each, 30 wR, 10 nwR, 10 wD, 30 nwR
 samp[,2] <- c(rep(1,30), rep(0,10), rep(1,10), rep(0,30))
 #fill policy support: only white republicans support, the first 30 rows
 samp[,3] <- c(rep(1,30), rep(0,50))
 #see directly that sample average support is 37.5\%
 mean(samp[,3])
 
 ###### Mean Balancing
 #normally, to reweight our sample to the population we would use mean balancing
 #since we don't know the interaction between party and race is the relevant covariate
 #to balance on, we would simply reweigth our sample based on race, and party separately
 #given that we have equal n in each of these two covariates, there's nothing to readjust
 #mean balancing cannot get us any closer to the correct population estimate 
 #since we already have mean balance party and race and
 #we just end up just where we started
 
 #to see this explicitly, we can run ebalance to get essentially perfect mean balance
 #first combine the data for ebal()
 dat <- rbind(pop,samp)
 #build a vector indicating which units are sampled(1) and which are population units(0)
 sampled <- c(rep(0,800), rep(1,80))
 
 #run ebal (treatment = population units = 1-sampled)
 ebal_out <- ebal::ebalance(Treatment = 1-sampled, 
                            X=dat[,1:2],
                            constraint.tolerance=1e-6, 
                            print.level=-1)
 
 #we can see that they are all weighted evenly to scale the sample by ten from 80 to 800
 unique(ebal_out$w)
 #and we end up with the same estimate we started with
 weighted.mean(samp[,3], w = ebal_out$w)
 
 ####### Kernel Balancing
 #now we can see how kernel balancing can find these higher order combinations 
 #of covariates for us to get excellent balance and sample estimates 
 #even if we don't know to seek balance on these combinations ourselves
 kbalout = kbal(allx=dat[,1:2],
                useasbases=rep(1,nrow(dat)), 
                sampled = sampled, 
                b = 1,
                sampledinpop = FALSE)
                
 #we no longer get even weights for the sampled units
 kbalout$w[sampled ==1]
 #and we end up with the correct estimate
 weighted.mean(samp[,3], w = kbalout$w[sampled==1])    
}
